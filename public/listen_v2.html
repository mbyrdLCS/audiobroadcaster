<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audio Listener</title>
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            color: #fff;
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        .container {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            max-width: 400px;
            width: 90%;
            text-align: center;
            transition: transform 0.3s ease;
        }
        .container:hover {
            transform: translateY(-5px);
        }
        .logo {
            width: 120px;
            margin-bottom: 20px;
        }
        h1 {
            font-size: 2em;
            margin-bottom: 10px;
            color: #fff;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        p {
            font-size: 1em;
            margin-bottom: 20px;
            color: #d0e1ff;
        }
        audio {
            width: 100%;
            max-width: 300px;
            margin: 15px auto;
            display: block;
            border-radius: 10px;
            background: #fff;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }
        select {
            background: #fff;
            border: none;
            padding: 10px;
            font-size: 1em;
            border-radius: 10px;
            margin: 10px 0;
            width: 100%;
            max-width: 300px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            cursor: pointer;
            color: #333;
        }
        button {
            background: linear-gradient(45deg, #00c6ff, #0072ff);
            border: none;
            padding: 12px 24px;
            font-size: 1em;
            color: #fff;
            border-radius: 25px;
            cursor: pointer;
            margin: 5px;
            transition: background 0.3s ease, transform 0.2s ease;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }
        button:hover {
            background: linear-gradient(45deg, #0072ff, #00c6ff);
            transform: scale(1.05);
        }
        #speakButton {
            background: linear-gradient(45deg, #dc3545, #c82333);
        }
        #speakButton:hover {
            background: linear-gradient(45deg, #c82333, #dc3545);
        }
        @keyframes pulse-speak {
            0%, 100% { box-shadow: 0 0 0 0 rgba(40, 167, 69, 0.7); transform: scale(1); }
            50% { box-shadow: 0 0 0 10px rgba(40, 167, 69, 0); transform: scale(1.05); }
        }
        #speakButton.needs-tap {
            background: linear-gradient(45deg, #28a745, #218838) !important;
            animation: pulse-speak 1.2s ease-in-out infinite;
        }
        #volumeControl {
            width: 100%;
            max-width: 300px;
            margin: 10px auto;
            display: block;
            -webkit-appearance: none;
            height: 8px;
            border-radius: 5px;
            background: #d0e1ff;
            outline: none;
            opacity: 0.8;
            transition: opacity 0.2s;
        }
        #volumeControl:hover {
            opacity: 1;
        }
        #volumeControl::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(45deg, #00c6ff, #0072ff);
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
        }
        #translatedText {
            margin-top: 20px;
            font-size: 1.1em;
        }
        #logTextarea { 
            width: 100%;
            height: 100px;
            margin-top: 10px;
            background: #fff;
            color: #000;
            border-radius: 5px;
            padding: 5px;
            font-family: monospace;
            font-size: 12px;
        }
        #selectAllButton {
            background: linear-gradient(45deg, #6f42c1, #5a32a8);
            border: none;
            padding: 8px 16px;
            font-size: 0.9em;
            color: #fff;
            border-radius: 25px;
            cursor: pointer;
            margin-top: 5px;
            transition: background 0.3s ease, transform 0.2s ease;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }
        #selectAllButton:hover {
            background: linear-gradient(45deg, #5a32a8, #6f42c1);
            transform: scale(1.05);
        }
        #debug {
            background: rgba(0, 0, 0, 0.7);
            color: #fff;
            padding: 10px;
            margin-top: 20px;
            border-radius: 10px;
            max-height: 200px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 12px;
            text-align: left;
        }
    </style>
</head>
<body>
    <div class="container">
        <img src="/Logo_primary_RGB.png" alt="ChurchApps Logo" class="logo">
        <h1>Audio Listener</h1>
        <p>Tap Play to tune in</p>
        <audio id="audioPlayer" controls controlslist="nodownload" preload="auto"></audio>
        <button id="playButton">Play</button>
        <button id="reloadButton">Reload</button>
        <button id="copyLogs">Copy Logs</button>
        <button id="speakButton">Auto-Speak: OFF</button>
        <select id="targetLanguage">
            <option value="en">English (no translation)</option>
            <option value="es">Spanish (Español)</option>
            <option value="fr">French (Français)</option>
            <option value="de">German (Deutsch)</option>
            <option value="zh">Chinese (中文)</option>
            <option value="pt">Portuguese (Português)</option>
            <option value="ru">Russian (Русский)</option>
            <option value="ar">Arabic (العربية)</option>
            <option value="ko">Korean (한국어)</option>
            <option value="ja">Japanese (日本語)</option>
            <option value="hi">Hindi (हिन्दी)</option>
            <option value="it">Italian (Italiano)</option>
        </select>
        <input type="range" id="volumeControl" min="0" max="1" step="0.01" value="1">
        <div id="translatedText"></div>
        <textarea id="logTextarea" readonly></textarea>
        <button id="selectAllButton">Select All</button>
        <div id="debug"></div>
    </div>

    <script>
        // Optional: Set your email for 10x MyMemory rate limit (10,000 words/day vs 1,000)
        const MYMEMORY_EMAIL = '';

        let socket;
        const audioPlayer = document.getElementById('audioPlayer');
        const debug = document.getElementById('debug');
        const playButton = document.getElementById('playButton');
        const reloadButton = document.getElementById('reloadButton');
        const copyLogsButton = document.getElementById('copyLogs');
        const speakButton = document.getElementById('speakButton');
        const volumeControl = document.getElementById('volumeControl');
        const logTextarea = document.getElementById('logTextarea');
        const translatedTextDiv = document.getElementById('translatedText');
        let pc = null;
        let mediaStream = null;
        let hasInteracted = false;
        let isInitialized = false;
        let lastTranslatedText = '';
        let lastTranslatedLang = 'en';
        let speechEnabled = false;
        let translationEnabled = false; // Will be set by translation-state event from server

        const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;

        // Cache voices — Chrome (Android) loads them async via onvoiceschanged
        let cachedVoices = window.speechSynthesis.getVoices();
        window.speechSynthesis.onvoiceschanged = () => {
            cachedVoices = window.speechSynthesis.getVoices();
        };

        // iOS must pause() to release the audio session for TTS to be heard.
        // Android doesn't have that conflict — muting is enough and avoids stream buffering issues.
        function pauseAudioForTTS() {
            if (isIOS) audioPlayer.pause();
            else audioPlayer.muted = true;
        }
        function resumeAudioAfterTTS() {
            audioPlayer.muted = false;
            if (isIOS) audioPlayer.play().catch(() => {});
        }

        async function translateText(text, lang) {
            if (!text || lang === 'en') return text;
            try {
                let url = `https://api.mymemory.translated.net/get?q=${encodeURIComponent(text)}&langpair=en|${lang}`;
                if (MYMEMORY_EMAIL) url += `&de=${encodeURIComponent(MYMEMORY_EMAIL)}`;
                const controller = new AbortController();
                const timeout = setTimeout(() => controller.abort(), 5000);
                const res = await fetch(url, { signal: controller.signal });
                clearTimeout(timeout);
                const data = await res.json();
                return data?.responseData?.translatedText || text;
            } catch (e) {
                log(`Translation error: ${e.message}`);
                return text;
            }
        }

        function log(message) {
            const now = new Date().toLocaleTimeString();
            debug.innerText += `[${now}] ${message}\n`;
            logTextarea.value = debug.innerText;
            debug.scrollTop = debug.scrollHeight;
            console.log(message);
        }

        async function initializeWebRTC() {
            if (pc) pc.close();
            pc = new RTCPeerConnection({
                iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
            });

            pc.onicecandidate = (event) => {
                if (event.candidate) {
                    socket.emit('ice-candidate', event.candidate);
                    log('ICE candidate sent');
                }
            };

            pc.ontrack = (event) => {
                log('Received remote track');
                mediaStream = event.streams[0];
                log(`Stream tracks: ${mediaStream.getAudioTracks().length}`);
                audioPlayer.srcObject = mediaStream;
                audioPlayer.volume = volumeControl.value;
                // Don't play raw audio if Auto-Speak is active (listener wants TTS only)
                if (hasInteracted && !(speechEnabled && translationEnabled)) {
                    audioPlayer.muted = false;
                    audioPlayer.play().then(() => log('Audio playing'))
                        .catch(err => log(`Play error: ${err.message}`));
                }
            };

            pc.onconnectionstatechange = () => {
                log(`Connection state: ${pc.connectionState}`);
                if (pc.connectionState === 'failed' || pc.connectionState === 'disconnected') {
                    log('Connection lost, reconnecting...');
                    initializeWebRTC();
                    socket.emit('listener');
                }
            };
        }

        async function togglePlayPause() {
            hasInteracted = true;
            if (audioPlayer.paused) {
                if (!mediaStream || mediaStream.getAudioTracks().length === 0) {
                    log('No stream available, initializing...');
                    initializeWebRTC();
                    socket.emit('listener');
                    return;
                }
                try {
                    await audioPlayer.play();
                    playButton.textContent = 'Pause';
                    log('Playing');
                } catch (err) {
                    log(`Play error: ${err.message}`);
                }
            } else {
                audioPlayer.pause();
                playButton.textContent = 'Play';
                log('Paused');
            }
        }

        let speechResumeInterval = null;

        function speakText(text) {
            window.speechSynthesis.cancel();
            if (speechResumeInterval) { clearInterval(speechResumeInterval); speechResumeInterval = null; }

            pauseAudioForTTS();

            const utterance = new SpeechSynthesisUtterance(text);
            const region = lastTranslatedLang === 'zh' ? 'CN' : (lastTranslatedLang === 'pt' ? 'BR' : lastTranslatedLang.toUpperCase());
            utterance.lang = `${lastTranslatedLang}-${region}`;

            const matchedVoice = cachedVoices.find(v => v.lang.toLowerCase().startsWith(lastTranslatedLang.toLowerCase()))
                || cachedVoices.find(v => v.lang.toLowerCase().includes(lastTranslatedLang.toLowerCase()));
            if (matchedVoice) {
                utterance.voice = matchedVoice;
                log(`Speaking (${matchedVoice.name}): ${text}`);
            } else {
                log(`Speaking [${lastTranslatedLang}]: ${text}`);
            }

            utterance.onend = () => {
                if (speechResumeInterval) { clearInterval(speechResumeInterval); speechResumeInterval = null; }
                if (!speechEnabled) resumeAudioAfterTTS();
            };
            utterance.onerror = (event) => {
                if (speechResumeInterval) { clearInterval(speechResumeInterval); speechResumeInterval = null; }
                log(`Speech error: ${event.error}`);
                if (!speechEnabled) resumeAudioAfterTTS();
            };

            try {
                window.speechSynthesis.speak(utterance);
                // iOS Safari randomly pauses itself mid-sentence — poll and resume
                if (isIOS) {
                    speechResumeInterval = setInterval(() => {
                        if (!window.speechSynthesis.speaking) {
                            clearInterval(speechResumeInterval); speechResumeInterval = null;
                        } else if (window.speechSynthesis.paused) {
                            window.speechSynthesis.resume();
                        }
                    }, 250);
                }
            } catch (err) {
                log(`Speech failed: ${err.message}`);
                if (!speechEnabled) resumeAudioAfterTTS();
            }
        }

        // iOS requires speech synthesis to be primed from a direct user touch.
        // Prime it on the very first touch anywhere on the page.
        document.body.addEventListener('touchstart', () => {
            const primer = new SpeechSynthesisUtterance('');
            window.speechSynthesis.speak(primer);
        }, { once: true, passive: true });

        function initializeApp() {
            if (isInitialized) return;
            isInitialized = true;

            socket = io(window.location.origin, { transports: ['websocket'] });
            initializeWebRTC();

            socket.on('connect', () => {
                log('Connected to server');
                socket.emit('listener');
            });

            socket.on('offer', async (offer) => {
                try {
                    await pc.setRemoteDescription(offer);
                    const answer = await pc.createAnswer();
                    await pc.setLocalDescription(answer);
                    socket.emit('answer', answer);
                    log('Answer sent');
                } catch (err) {
                    log(`Error handling offer: ${err.message}`);
                }
            });

            socket.on('ice-candidate', async (candidate) => {
                try {
                    if (pc.remoteDescription) {
                        await pc.addIceCandidate(candidate);
                        log('ICE candidate added');
                    }
                } catch (err) {
                    log(`ICE candidate error: ${err.message}`);
                }
            });

            socket.on('transcribed-text', async ({ text }) => {
                const lang = document.getElementById('targetLanguage').value;
                // Silence raw audio immediately (before async translation) so English doesn't bleed through
                if (speechEnabled && translationEnabled) pauseAudioForTTS();
                const translated = await translateText(text, lang);
                log(`Transcribed [${lang}]: ${translated}`);
                translatedTextDiv.textContent = translated;
                lastTranslatedText = translated;
                lastTranslatedLang = lang;
                if (speechEnabled && translated) speakText(translated);
            });

            socket.on('translation-state', (state) => {
                translationEnabled = state;
                log(`Translation ${state ? 'enabled' : 'disabled'} by broadcaster`);
                translatedTextDiv.style.display = state ? '' : 'none';
                if (!state) {
                    translatedTextDiv.textContent = '';
                    resumeAudioAfterTTS();
                }
            });

            socket.on('disconnect', () => log('Disconnected from server'));

            playButton.addEventListener('click', togglePlayPause);
            reloadButton.addEventListener('click', () => window.location.reload());
            copyLogsButton.addEventListener('click', () => {
                const logs = logTextarea.value;
                if (navigator.clipboard) {
                    navigator.clipboard.writeText(logs)
                        .then(() => log('Logs copied to clipboard'))
                        .catch(() => fallbackCopy());
                } else {
                    fallbackCopy();
                }
                function fallbackCopy() {
                    logTextarea.select();
                    try {
                        document.execCommand('copy');
                        log('Logs copied');
                    } catch {
                        log('Long-press the log area below and select Copy');
                    }
                }
            });
            selectAllButton.addEventListener('click', () => {
                logTextarea.select();
                log('Logs selected, please copy manually');
                try {
                    document.execCommand('copy');
                    log('Logs copied to clipboard via fallback');
                } catch (err) {
                    log('Manual copy required: long-press the textarea and select "Copy"');
                }
            });
            speakButton.addEventListener('click', () => {
                // If pulsing (waiting for first tap), treat this click as "enable"
                const wasPulsing = speakButton.classList.contains('needs-tap');
                speechEnabled = wasPulsing ? true : !speechEnabled;
                speakButton.classList.remove('needs-tap');
                speakButton.textContent = speechEnabled ? 'Auto-Speak: ON' : 'Auto-Speak: OFF';
                speakButton.style.background = speechEnabled
                    ? 'linear-gradient(45deg, #28a745, #218838)'
                    : 'linear-gradient(45deg, #dc3545, #c82333)';
                if (speechEnabled && translationEnabled) {
                    pauseAudioForTTS();
                } else {
                    resumeAudioAfterTTS();
                }
                log(`Auto-speak ${speechEnabled ? 'enabled' : 'disabled'}`);

                // iOS Safari fix: Prime speech synthesis with a direct user interaction (click = trusted gesture)
                if (speechEnabled) {
                    const primer = new SpeechSynthesisUtterance('');
                    window.speechSynthesis.speak(primer);
                }

                // If turning on and there's text, speak it immediately
                if (speechEnabled && lastTranslatedText) {
                    speakText(lastTranslatedText);
                }
            });
            document.getElementById('targetLanguage').addEventListener('change', (e) => {
                const lang = e.target.value;
                if (lang === 'en') {
                    // Switching to English: disable speech
                    if (speechEnabled) {
                        speechEnabled = false;
                        speakButton.textContent = 'Auto-Speak: OFF';
                        speakButton.style.background = 'linear-gradient(45deg, #dc3545, #c82333)';
                        speakButton.classList.remove('needs-tap');
                        audioPlayer.muted = false;
                        log('Auto-speak disabled (English selected)');
                    }
                } else if (!speechEnabled) {
                    if (isIOS) {
                        // iOS blocks speechSynthesis from select change events — pulse button for one tap
                        speakButton.classList.add('needs-tap');
                        speakButton.textContent = 'Tap to Enable Voice';
                        log(`Language set to ${lang} — tap Auto-Speak button to enable voice`);
                    } else {
                        // Android/Chrome: change events are trusted gestures, auto-enable directly
                        speechEnabled = true;
                        speakButton.textContent = 'Auto-Speak: ON';
                        speakButton.style.background = 'linear-gradient(45deg, #28a745, #218838)';
                        if (translationEnabled) pauseAudioForTTS();
                        const primer = new SpeechSynthesisUtterance('');
                        window.speechSynthesis.speak(primer);
                        log(`Auto-speak enabled for language: ${lang}`);
                    }
                }
                // If speechEnabled is already true (already activated), nothing extra needed.
            });
            volumeControl.addEventListener('input', () => {
                audioPlayer.volume = volumeControl.value;
                log(`Volume set to ${volumeControl.value}`);
            });

            audioPlayer.volume = volumeControl.value;
        }

        document.addEventListener('DOMContentLoaded', initializeApp);
    </script>
</body>
</html>